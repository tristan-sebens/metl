#' Decoder base class
#'
#' Logical representation of a single tag, which contains all necessary logic to parse and extract all required data from an appropriately formatted directory. Contains one or more [DataMap] objects, each of which the Decoder will apply in turn to the directory in order to extract the necessary data. Contains an [Identifier] object, which can be used to automatically determine if a given directory contains the data generated by a tag of the make/model to which this Decoder refers.
#'
#' @field metadata_map DataMap. The [DataMap] used to extract the tag metadata
#' @field data_maps list. The list of data maps used to map the data for this tag to the output tables in the DB
#'
#' @export
Decoder =
  #----
setRefClass(
  "Decoder",
  fields =
    list(
      identifier = "Identifier",
      metadata_map = "DataMap",
      instant_datamap = "DataMap",
      summary_datamap = "DataMap"
    ),

  methods =
    list(
      initialize =
        function(
    ...,
    instant_datamap =
      DataMap(extract_fn = function(d) return(data.frame())),
    summary_datamap =
      DataMap(extract_fn = function(d) return(data.frame()))
        ) {
          callSuper(
            ...,
            instant_datamap = instant_datamap,
            summary_datamap = summary_datamap
          )
        },
    # Execute all necessary steps to read and transform raw data for one DataMap
    decode_datamap =
      function(d, dm, op_fm, type) {
        "Execute all necessary steps to read and transform raw data for one DataMap"
        try_catch_decorate(
          expr =
            {
              # Perform initial extraction
              dat =
                dm$extract(d)

              # Transform extracted data
              dat_t =
                dm$transform(dat, op_fm)

              # Return transformed data
              return(dat_t)
            },
          data_type = type
        )
      },

    decode_metadata_map =
      function(d, op_fm) {
        .self$decode_datamap(
          d,
          .self$metadata_map,
          op_fm,
          type = "meta"
        )
      },

    decode_instant_datamap =
      function(d, op_fm) {
        .self$decode_datamap(
          d,
          .self$instant_datamap,
          op_fm,
          type = "instant"
        )
      },

    decode_summary_datamap =
      function(d, op_fm) {
        .self$decode_datamap(
          d,
          .self$summary_datamap,
          op_fm,
          type = "summary"
        )
      }
    )
)
