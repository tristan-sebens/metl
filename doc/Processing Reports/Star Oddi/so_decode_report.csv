"dir","pct_decoded","decoded","identified_decoder","decode_error"
"Star Oddi         ",85.7,NA,NA,NA
" ¦--DST magnetic  ",71.4,NA,NA,NA
" ¦   °--Sablefish ",71.4,NA,NA,NA
" ¦       ¦--JS893 ",NA,FALSE,"","Assigned data `input_field_dat_` must be compatible with existing data., , tp__$process(con), tp__$dir_tree__$Do(function(node) {
    print(node$levelName)
    if (node$isLeaf) {
        .self$process_directory(node, con)
    }
}), Do(t, fun, ...), fun(node, ...), .self$process_directory(node, con), tryCatch({
    dc$decode(con, overwrite = .self$overwrite)
    data_directory$decoded = T
    data_directory$identified_decoder = pos_id$name
}, error = function(cond) {
    data_directory$decode_error = cond
}), tryCatchList(expr, classes, parentenv, handlers), tryCatchOne(expr, names, parentenv, handlers[[1]]), doTryCatch(return(expr), name, parentenv, handler), dc$decode(con, overwrite = .self$overwrite), DBI::dbWithTransaction(con, {
    .self$upload_meta(con)
    .self$decode_and_load_all_datamaps(con)
}), DBI::dbWithTransaction(con, {
    .self$upload_meta(con)
    .self$decode_and_load_all_datamaps(con)
}), .local(conn, code, ...), tryCatch({
    res <- force(code)
    call <- dbCommit(conn)
    if (identical(call, FALSE)) {
        stop(""Failed to commit transaction"", call. = FALSE)
    }
    res
}, dbi_abort = rollback_because, error = rollback_because), tryCatchList(expr, classes, parentenv, handlers), tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], parentenv, handlers[[nh]]), doTryCatch(return(expr), name, parentenv, handler), tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), tryCatchOne(expr, names, parentenv, handlers[[1]]), doTryCatch(return(expr), name, parentenv, handler), force(code), .self$decode_and_load_all_datamaps(con), .self$decode_datamap(dm), dm$transform(dat), .self$transform_fields(dat), `[<-`(`*tmp*`, output_field_obj_$name, value = `<[m]>`), `[<-.tbl_df`(`*tmp*`, output_field_obj_$name, value = `<[m]>`), tbl_subassign(x, i, j, value, i_arg, j_arg, substitute(value)), vectbl_recycle_rhs_rows(value, fast_nrow(xo), i_arg = NULL, value_arg, call), withCallingHandlers(for (j in seq_along(value)) {
    if (!is.null(value[[j]])) {
        value[[j]] <- vec_recycle(value[[j]], nrow)
    }
}, vctrs_error_recycle_incompatible_size = function(cnd) {
    abort_assign_incompatible_size(nrow, value, j, i_arg, value_arg, cnd, call = call)
}, vctrs_error_scalar_type = function(cnd) {
    abort_assign_vector(value, j, value_arg, cnd, call = call)
}), vec_recycle(value[[j]], nrow), stop_recycle_incompatible_size(x_size = 0, size = 333, x_arg = """", call = `<env>`), stop_vctrs(x_size = x_size, y_size = size, x_arg = x_arg, class = c(""vctrs_error_incompatible_size"", ""vctrs_error_recycle_incompatible_size""), call = call), abort(message, class = c(class, ""vctrs_error""), ..., call = call), 0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 10, 10, 12, 13, 14, 15, 16, 15, 18, 19, 13, 10, 22, 23, 24, 25, 25, 27, 28, 29, 29, 0, 32, 33, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, NA, NA, data.tree, NA, NA, base, base, base, base, NA, DBI, DBI, DBI, base, base, base, base, base, base, base, base, NA, NA, NA, NA, base, tibble, tibble, tibble, base, vctrs, vctrs, vctrs, rlang, NA, NA, ::, NA, NA, ::, local, local, local, NA, ::, ::, local, ::, local, local, local, local, local, local, ::, NA, NA, NA, NA, ::, :::, :::, :::, ::, ::, :::, :::, ::, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, 333, , TRUE, vectbl_recycle_rhs_rows(value, fast_nrow(xo), i_arg = NULL, value_arg, call), 333, 0, 1, Existing data has 333 rows., Assigned data has 0 rows., Only vectors of size 1 are recycled., TRUE, `[<-`(`*tmp*`, output_field_obj_$name, value = numeric(0)), TRUE"
" ¦       ¦--JS923 ",NA,TRUE,"Decoder_StarOddi_DSTmagnetic",""
" ¦       ¦--JS925 ",NA,TRUE,"Decoder_StarOddi_DSTmagnetic",""
" ¦       ¦--JS927 ",NA,TRUE,"Decoder_StarOddi_DSTmagnetic",""
" ¦       ¦--JS929 ",NA,TRUE,"Decoder_StarOddi_DSTmagnetic",""
" ¦       ¦--JS930 ",NA,FALSE,"","Assigned data `input_field_dat_` must be compatible with existing data., , tp__$process(con), tp__$dir_tree__$Do(function(node) {
    print(node$levelName)
    if (node$isLeaf) {
        .self$process_directory(node, con)
    }
}), Do(t, fun, ...), fun(node, ...), .self$process_directory(node, con), tryCatch({
    dc$decode(con, overwrite = .self$overwrite)
    data_directory$decoded = T
    data_directory$identified_decoder = pos_id$name
}, error = function(cond) {
    data_directory$decode_error = cond
}), tryCatchList(expr, classes, parentenv, handlers), tryCatchOne(expr, names, parentenv, handlers[[1]]), doTryCatch(return(expr), name, parentenv, handler), dc$decode(con, overwrite = .self$overwrite), DBI::dbWithTransaction(con, {
    .self$upload_meta(con)
    .self$decode_and_load_all_datamaps(con)
}), DBI::dbWithTransaction(con, {
    .self$upload_meta(con)
    .self$decode_and_load_all_datamaps(con)
}), .local(conn, code, ...), tryCatch({
    res <- force(code)
    call <- dbCommit(conn)
    if (identical(call, FALSE)) {
        stop(""Failed to commit transaction"", call. = FALSE)
    }
    res
}, dbi_abort = rollback_because, error = rollback_because), tryCatchList(expr, classes, parentenv, handlers), tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), names[nh], parentenv, handlers[[nh]]), doTryCatch(return(expr), name, parentenv, handler), tryCatchList(expr, names[-nh], parentenv, handlers[-nh]), tryCatchOne(expr, names, parentenv, handlers[[1]]), doTryCatch(return(expr), name, parentenv, handler), force(code), .self$decode_and_load_all_datamaps(con), .self$decode_datamap(dm), dm$transform(dat), .self$transform_fields(dat), `[<-`(`*tmp*`, output_field_obj_$name, value = `<[m]>`), `[<-.tbl_df`(`*tmp*`, output_field_obj_$name, value = `<[m]>`), tbl_subassign(x, i, j, value, i_arg, j_arg, substitute(value)), vectbl_recycle_rhs_rows(value, fast_nrow(xo), i_arg = NULL, value_arg, call), withCallingHandlers(for (j in seq_along(value)) {
    if (!is.null(value[[j]])) {
        value[[j]] <- vec_recycle(value[[j]], nrow)
    }
}, vctrs_error_recycle_incompatible_size = function(cnd) {
    abort_assign_incompatible_size(nrow, value, j, i_arg, value_arg, cnd, call = call)
}, vctrs_error_scalar_type = function(cnd) {
    abort_assign_vector(value, j, value_arg, cnd, call = call)
}), vec_recycle(value[[j]], nrow), stop_recycle_incompatible_size(x_size = 0, size = 4286, x_arg = """", call = `<env>`), stop_vctrs(x_size = x_size, y_size = size, x_arg = x_arg, class = c(""vctrs_error_incompatible_size"", ""vctrs_error_recycle_incompatible_size""), call = call), abort(message, class = c(class, ""vctrs_error""), ..., call = call), 0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 10, 10, 12, 13, 14, 15, 16, 15, 18, 19, 13, 10, 22, 23, 24, 25, 25, 27, 28, 29, 29, 0, 32, 33, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, NA, NA, data.tree, NA, NA, base, base, base, base, NA, DBI, DBI, DBI, base, base, base, base, base, base, base, base, NA, NA, NA, NA, base, tibble, tibble, tibble, base, vctrs, vctrs, vctrs, rlang, NA, NA, ::, NA, NA, ::, local, local, local, NA, ::, ::, local, ::, local, local, local, local, local, local, ::, NA, NA, NA, NA, ::, :::, :::, :::, ::, ::, :::, :::, ::, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, 4286, , TRUE, vectbl_recycle_rhs_rows(value, fast_nrow(xo), i_arg = NULL, value_arg, call), 4286, 0, 1, Existing data has 4286 rows., Assigned data has 0 rows., Only vectors of size 1 are recycled., TRUE, `[<-`(`*tmp*`, output_field_obj_$name, value = numeric(0)), TRUE"
" ¦       °--JS932 ",NA,TRUE,"Decoder_StarOddi_DSTmagnetic",""
" ¦--DST milli-F   ",100,NA,NA,NA
" ¦   °--Sablefish ",100,NA,NA,NA
" ¦       ¦--JS108 ",NA,TRUE,"Decoder_StarOddi_DST",""
" ¦       ¦--JS122 ",NA,TRUE,"Decoder_StarOddi_DST",""
" ¦       ¦--JS1229",NA,TRUE,"Decoder_StarOddi_DST",""
" ¦       ¦--JS142 ",NA,TRUE,"Decoder_StarOddi_DST",""
" ¦       ¦--JS43  ",NA,TRUE,"Decoder_StarOddi_DST",""
" ¦       °--JS47  ",NA,TRUE,"Decoder_StarOddi_DST",""
" °--DST           ",100,NA,NA,NA
"     °--Sablefish ",100,NA,NA,NA
"         °--JS7977",NA,TRUE,"Decoder_StarOddi_DST",""
